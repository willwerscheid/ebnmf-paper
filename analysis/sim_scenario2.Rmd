---
title: NMF analyses of simulated data, Scenario 2
author: Jason Willwerscheid and Peter Carbonetto
output:
  workflowr::wflow_html:
    toc: yes
    theme: readable
    highlight: textmate
    lib_dir: site_libs
    self_contained: no
---

```{r knitr-opts, include=FALSE}
knitr::opts_chunk$set(comment = "#",collapse = TRUE,results = "hold",
                      fig.align = "center",dpi = 120)
```

```{r load-pkgs, message=FALSE}
library(R.matlab)
library(tibble)
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(cowplot)
library(ebnm)
library(flashier)
library(fastTopics)
source("./code/sim_functions.R")
```

For details on fitting methods and evaluation metrics, see our previous analysis in `analysis/sim_scenario1b.Rmd`.

### Scenario

In this analysis we consider the "shared topics" scenario. Here there are six populations: three "pure" populations defined by a single topic each, and three "mixed" populations, each of which is an admixture of 2 of the three pure populations (with varying admixture proportions). We vary the relative size of pure and mixed populations, from 25 pure and 975 mixed to 975 mixed and 25 pure for each population. The `L` matrix codes population memberships. The factors `F` and the `log1p` link function are as in the previous analysis.

```{r}
sim_data <- function(ns, p, dispersion, n_anchor_words = 3) {
  pops <- rep(LETTERS[1:length(ns)], times = ns)
  
  L <- matrix(0, nrow = sum(ns), ncol = 3)
  pi1 <- seq(0, 1, length.out = ns[4])
  pi2 <- seq(0, 1, length.out = ns[5])
  pi3 <- seq(0, 1, length.out = ns[6])
  L[, 1] <- c(rep(1, ns[1]), rep(0, sum(ns[2:3])), pi1, pi2, rep(0, ns[6]))
  L[, 2] <- c(rep(0, ns[1]), rep(1, ns[2]), rep(0, ns[3]), 1 - pi1, rep(0, ns[5]), pi3)
  L[, 3] <- c(rep(0, sum(ns[1:2])), rep(1, ns[3]), rep(0, ns[4]), 1 - pi2, 1 - pi3)
  
  F <- sim_F(p, 3, gamma_shape = 2/3, gamma_scale = 1, n_anchor_words)
  X <- sim_X(L, F, dispersion = dispersion)
  return_sim_data(X, L, F, pops)
}

run_sims <- function(which_dat, Kmax, verbose = FALSE) {
  all_res <- tibble()
  next_seed <- 0
  for (varied_n in c(25, 100, 500, 900, 975)) { 
    for (disp in c(0.1, 1, 10, 100, 10000)) {
      if (verbose) cat("SHARED N: ", varied_n, "DISPERSION: ", disp, "\n")
      
      ns <- c(rep(1000 - varied_n, 3), rep(varied_n, 3))
      p <- 1000
      
      next_seed <- next_seed + 1
      set.seed(next_seed)
      sim_dat <- sim_data(ns, p, disp)
      
      dat <- sim_dat[[which_dat]]
      
      if (verbose) cat(" NMF...\n")
      nmf_res <-  run_RcppML_sparse_nmf(dat, k = Kmax, L1pen = 0, seeds = 1:10)
      all_res <- all_res |> 
        bind_rows(next_tib(next_seed, disp, ns, "NMF", Kmax, nmf_res, sim_dat))
      
      L1pens <- c(0.05, 0.1, 0.25, 0.5, 0.75) 
      for (L1pen in L1pens) {
        if (verbose) cat(" Sparse NMF, L1 = ", L1pen, "...\n")
        spnmf_res <- run_RcppML_sparse_nmf(dat, k = Kmax, L1pen = L1pen, seeds = 1:10)
        all_res <- all_res |> 
          bind_rows(next_tib(next_seed, disp, ns, paste0("SpNMF", L1pen), Kmax, spnmf_res, sim_dat))
      }
      
      if (verbose) cat(" NMF-EBNMF...\n")
      ebnmf_nmf_res <- run_ebnmf_from_nmf(dat, nmf_res$fit)
      all_res <- all_res |> 
        bind_rows(next_tib(next_seed, disp, ns, "NMF-EBNMF", Kmax, ebnmf_nmf_res, sim_dat))
      
      if (verbose) cat(" NMF-EBNMF (var type = 0)...\n")
      ebnmf_nmf_vt0_res <- run_ebnmf_from_nmf(dat, nmf_res$fit, var_type = 0)
      all_res <- all_res |> 
        bind_rows(next_tib(next_seed, disp, ns, "NMF-EBNMF-vt0", Kmax, ebnmf_nmf_vt0_res, sim_dat))
      
      if (verbose) cat(" EBNMFgb...\n")
      ebnmf_gb_res <- run_greedy_backfit(dat, Kmax = Kmax)
      all_res <- all_res |> 
        bind_rows(next_tib(next_seed, disp, ns, "EBNMFgb", Kmax, ebnmf_gb_res, sim_dat))
      
      if (verbose) cat(" EBNMFgb (var type = 0)...\n")
      ebnmf_gb_vt0_res <- run_greedy_backfit(dat, Kmax = Kmax, var_type = 0)
      all_res <- all_res |> 
        bind_rows(next_tib(next_seed, disp, ns, "EBNMFgb-vt0", Kmax, ebnmf_gb_vt0_res, sim_dat))
      
      if (verbose) cat(" EBNMFalt...\n")
      ebnmf_alt_res <- run_alternating(dat, Kmax = Kmax)
      all_res <- all_res |> 
        bind_rows(next_tib(next_seed, disp, ns, "EBNMFalt", Kmax, ebnmf_alt_res, sim_dat))
      
      if (verbose) cat(" EBNMFalt (var type = 0)...\n")
      ebnmf_alt_vt0_res <- run_alternating(dat, Kmax = Kmax, var_type = 0)
      all_res <- all_res |> 
        bind_rows(next_tib(next_seed, disp, ns, "EBNMFalt-vt0", Kmax, ebnmf_alt_vt0_res, sim_dat))
      
    }
  }
  
  all_res <- all_res |>
    mutate(method = factor(method, levels = c(
      "NMF", paste0("SpNMF", L1pens), "NMF-EBNMF", "NMF-EBNMF-vt0", "EBNMFgb", "EBNMFgb-vt0",
      "EBNMFalt", "EBNMFalt-vt0"
    )))
  
  return(all_res)
}
```

### Results, Kmax = 3

```{r sims_3norm, echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE, results='hide'}
sims_3norm <- run_sims("Ynorm", Kmax = 3, verbose = FALSE)
```

Cosine similarities for `L` (normalized data). Each row gives correlations for one true component or "topic." Individual tiles correspond to individual simulations (a single combination of gamma shape and shared population size):

```{r}
xlab <- "Size of shared population"
ylab <- "Dispersion parameter"
make_cosplot(sims_3norm, "LLcos", xlab, ylab, "Cos. sim. w/ true L")
```

```{r sims_3nonorm, echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE, results='hide'}
sims_3nonorm <- run_sims("Y", Kmax = 3, verbose = FALSE)
```

Cosine similarities for `L` (non-normalized data):

```{r}
make_cosplot(sims_3nonorm, "LLcos", xlab, ylab, "Cos. sim. w/ true L")
```

Cosine similarities for `F` (non-normalized data):

```{r}
make_cosplot(sims_3nonorm, "FFcos", xlab, ylab, "Cos. sim. w/ true F", cutoff = 0.999)
```


### Results, Kmax = 6

```{r sims_6norm, echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE, results='hide'}
sims_6norm <- run_sims("Ynorm", Kmax = 6, verbose = FALSE)
```

```{r sims_6nonorm, echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE, results='hide'}
sims_6nonorm <- run_sims("Y", Kmax = 6, verbose = FALSE)
```

Cosine similarities for `L` (normalized):

```{r}
make_cosplot(sims_6norm, "LLcos", xlab, ylab, "Cos. sim. w/ true L")
```

SNR for redundant/noisy factors (normalized):

```{r}
make_scaleplot(sims_6norm, xlab, ylab, "SNR", cutoff = 100)
```

Cosine similarities for `L` (non-normalized):

```{r}
make_cosplot(sims_6nonorm, "LLcos", xlab, ylab, "Cos. sim. w/ true L")
```

Cosine similarities for `F` (non-normalized):

```{r}
make_cosplot(sims_6nonorm, "FFcos", xlab, ylab, "Cos. sim. w/ true F", cutoff = 0.999)
```

SNR for redundant/noisy factors (non-normalized):

```{r}
make_scaleplot(sims_6nonorm, xlab, ylab, "SNR", cutoff = 100)
```


### Timings

```{r}
all_res <- sims_3norm |>
  bind_rows(sims_3nonorm) |>
  bind_rows(sims_6norm) |>
  bind_rows(sims_6nonorm)
make_timingplot(all_res, xlab, ylab)
```

