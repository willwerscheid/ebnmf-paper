---
title: NMF analyses of simulated data, Scenario 1
author: Jason Willwerscheid and Peter Carbonetto
output:
  workflowr::wflow_html:
    toc: no
    theme: readable
    highlight: textmate
    lib_dir: site_libs
    self_contained: no
---

```{r knitr-opts, include=FALSE}
knitr::opts_chunk$set(comment = "#",collapse = TRUE,results = "hold",
                      fig.align = "center",dpi = 120)
```

```{r load-pkgs, message=FALSE}
library(R.matlab)
library(tibble)
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(cowplot)
library(ebnm)
library(flashier)
library(fastTopics)
source("code/swimmer_functions.R")
```

We use three different fitting methods:

1. "NMF": Uses package `NNLM`. As is common practice, we do 10 trials and choose the fit with the lowest error.

2. "NMF-EBNMF": EBNMF using an NMF initialization. We test `var_type = 0` and `var_type2`; we refer to these submethods as "NMF-EBNMF0" and "NMF-EBNMF2".

3. "EBNMF": An EBNMF fit produced by alternatively adding one "greedy" factor and running 10 backfitting iterations (so, we backfit after *each* new factor is added). After no new factor can be added, we perform a full backfit. We again test `var_type = 0` and `var_type2`, giving "EBNMF0" and "EBNMF2".

The fitting functions appear as follows:

```{r}
run_nmf <- function(Y, k, ntrials = 10) {
  cat("Running NMF")
  t <- system.time({
    best_mse <- Inf
    for (i in 1:ntrials) {
      cat(".")
      set.seed(i)
      next_res <- NNLM::nnmf(Y, k = k, verbose = 0)
      if (min(next_res$mse) < best_mse) {
        best_mse <- min(next_res$mse)
        best_res <- next_res
      }
    }
  })
  cat("\n")

  return(list(t = t, fit = best_res))
}

run_ebnmf_from_nmf <- function(Y, nmf_res, var_type, maxiter = 2000) {
  cat("Running EBNMF from NMF:\n")
  t <- system.time({
    fl <- flash_init(Y, var_type = var_type) |>
      flash_factors_init(list(nmf_res$W, t(nmf_res$H)), ebnm_fn = ebnm_point_exponential) |>
      flash_backfit(maxiter = maxiter, verbose = 0) |>
      flash_nullcheck(verbose = 0)
  })
  
  return(list(t = t, fit = fl))
}

run_alternating_gb <- function(Y, Kmax, var_type = 2) {
  cat("Running alternating EBNMF")
  t <- system.time({
    fl <- flash_init(Y, var_type = var_type) |>
      flash_set_verbose(0)
    keep_going <- TRUE
    while(keep_going) {
      cat(".")
      current_n <- fl$n_factors
      fl <- fl |>
        flash_greedy(ebnm_fn = ebnm_point_exponential) |>
        flash_backfit(maxiter = 10)
      if (fl$n_factors == current_n | fl$n_factors == Kmax) {
        keep_going <- FALSE
      }
    }
    cat("\n")
    fl <- fl |>
      flash_backfit(maxiter = 2000, verbose = 0) |>
      flash_nullcheck(verbose = 0)
  })
  
  return(list(t = t, fit = fl))
}
```

In this analysis we consider the "fully-separated topics" scenario. Here there are four populations of varying abundance; the most abundant population is of size 1150 to 1197, while the rarest population ranges from 3 to 50 individuals. The `L` matrix codes population memberships. The factors `F` are randomly generated from a Gamma distribution with mean 1, where the shape of the distribution ranges from 0.5 (so that counts vary widely across columns) to 2 (similar counts across columns). For separability in the `K = 4` case, we create 10 "anchor words" for each topic. Finally, we use a log1p link function in the sense that we simulate counts $X$ as Poisson($e^\mu - 1$), where $\mu = LF'$, and then take the data matrix to be $Y = \log(X + 1)$. 

```{r}
trueK <- 4 
highK <- 8 
n_anchor_words <- 10

sim_data <- function(ns, p, gamma_shape, gamma_scale, n_anchor_words = 10, link = "log1p") {
  k <- trueK
  
  # Loadings (document-topics):
  L <- matrix(0, nrow = sum(ns), ncol = k)
  L[, 1] <- c(rep(1, ns[1]), rep(0, sum(ns[2:4])))
  L[, 2] <- c(rep(0, ns[1]), rep(1, ns[2]), rep(0, sum(ns[3:4])))
  L[, 3] <- c(rep(0, sum(ns[1:2])), rep(1, ns[3]), rep(0, ns[4]))
  L[, 4] <- c(rep(0, sum(ns[1:3])), rep(1, ns[4]))
  
  set.seed(1)
  F <- matrix(rgamma(p * k, shape = gamma_shape, scale = gamma_scale), nrow = p, ncol = k)
  
  # Anchor words
  for (i in 1:k) {
    F[((i - 1) * n_anchor_words + 1):(i * n_anchor_words), setdiff(1:k, i)] <- 0
  }
  
  mu <- L %*% t(F)
  if (link == "identity") {
    Y <- matrix(rpois(sum(ns) * p, mu), nrow = sum(ns), ncol = p)
  } else if (link == "log1p") {
    Y <- matrix(log1p(rpois(sum(ns) * p, expm1(mu))), nrow = sum(ns), ncol = p)
  }
  
  # Make sure there aren't any all-zero columns:
  F <- F[apply(Y, 2, sum) > 0, ]
  Y <- Y[, apply(Y, 2, sum) > 0]
  
  rownames(Y) <- paste0("sample", 1:nrow(Y))
  colnames(Y) <- paste0("feature", 1:ncol(Y))

  return(list(Y = Y, L = L, F = F))
}
```

We consider the following metrics:

1. Correlation of the fitted `L` matrix with the true `L`. Since the order of columns is arbitrary, we "align" columns by taking the maximally correlated fitted column for each true topic. Note that since the true `L` is sparse, we expect EBNMF to outperform NMF.

2. Correlation of the fitted `F` matrix with the true `F`. The true `F` is dense (except for the anchor words), so we don't necessarily expect EBNMF to do much better than NMF. 

3. The relative scale of any extra fitted columns. In general, these column will either be noise or redundant with other components. We calculate the relative scale of column $i$ as

$$ \| \ell_i \|_2^2 / \sum_{k = 1}^K \| \ell_k \|_2^2. $$

4. The elapsed time taken to run the method. Note that **NMF times are for 10 separate runs, and NMF-EBNMF times are for the EBNMF portion of the fit only.** 

```{r}
calc_metrics <- function(res, sim_dat) {
  fit <- res$fit
  if (inherits(fit, "flash")) {
    LDF <- ldf(fit, type = "f")
    LL <- t(t(LDF$L) * LDF$D)
    FF <- t(t(LDF$F) * LDF$D)
  } else {
    Wscale <- sqrt(apply(fit$W, 2, function(x) sum(x^2)))
    Hscale <- sqrt(apply(fit$H, 1, function(x) sum(x^2)))
    D <- Wscale * Hscale
    LL <- t(t(fit$W) / sqrt(Wscale) * sqrt(Hscale))
    FF <- t(fit$H / sqrt(Hscale) * sqrt(Wscale))
  }
  
  # Metrics for components 1-K are correlations with true factors:
  LL_cors <- FF_cors <- rep(NA, trueK)
  used_cols <- numeric(0)
  LL_cormat <- cor(sim_dat$L, LL)
  FF_cormat <- cor(sim_dat$F, FF)
  for (i in 1:min(trueK, ncol(LL))) {
    rowmax <- which.max(apply(abs(LL_cormat), 1, max))
    colmax <- which.max(apply(abs(LL_cormat), 2, max))
    LL_cors[rowmax] <- LL_cormat[rowmax, colmax]
    FF_cors[rowmax] <- FF_cormat[rowmax, colmax]
    LL_cormat[, colmax] <- 0
    LL_cormat[rowmax, ] <- 0
    used_cols <- c(used_cols, colmax)
  }
  
  # Metrics for remaining are the scales of these (redundant/noisy) components:
  L_scales <- apply(LL, 2, function(x) sum(x^2))
  L_scales <- L_scales / sum(L_scales)
  unmatched_scales <- L_scales[-used_cols]
  unmatched_scales <- sort(unmatched_scales, decreasing = TRUE)
  unmatched_scales <- c(unmatched_scales, rep(NA, highK - trueK - length(unmatched_scales)))

  all_metrics <- c(LL_cors, FF_cors, unmatched_scales)
  names(all_metrics) <- c(
    paste0("LLcor", 1:trueK),
    paste0("FFcor", 1:trueK),
    paste0("Scale", (trueK + 1):highK)
  ) 
  
  return(all_metrics)
}

next_tib <- function(shape, ns, method, Kmax, res, sim_dat) {
  metrics <- calc_metrics(res, sim_dat)
  return(tibble(
    method = method,
    Kmax = Kmax,
    varied_n = ns[4],
    shape = shape,
    metric_type = c("t_elapsed", names(metrics)),
    metric_val = c(res$t[3], metrics)
  ))
}
```

Run simulations. We consider results for when the true `K = 4` is given in advance as well as for when `K` is overspecified (here, `Kmax = 8`). Since EBNMF can "choose" the total number of factors to add, `K` can be less than `Kmax`:

```{r echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE, results='hide'}
all_res <- tibble()

set.seed(1)
for (varied_n in  c(3, 5, 10, 20, 50)) { 
  for (shape in c(1/2, 2/3, 3/4, 1, 2)) { 
    cat("RARE N: ", varied_n, "SHAPE: ", shape, "\n")
    
    gamma_mean <- 1
    scale <- gamma_mean / shape 
    
    ns <- c(1200 - varied_n, 250, 50, varied_n)
    p <- 1000
    
    sim_dat <- sim_data(ns, p, gamma_shape = shape, gamma_scale = scale)
    Y <- sim_dat$Y
    
    nmf_res_trueK <- run_nmf(Y, k = trueK)
    all_res <- all_res |> 
      bind_rows(next_tib(shape, ns, "NMF", trueK, nmf_res_trueK, sim_dat))
    
    all_res <- all_res |> 
      bind_rows(next_tib(shape, ns, "NMF-EBNMF0", trueK, run_ebnmf_from_nmf(Y, nmf_res_trueK$fit, var_type = 0), sim_dat))
    
    all_res <- all_res |> 
      bind_rows(next_tib(shape, ns, "NMF-EBNMF2", trueK, run_ebnmf_from_nmf(Y, nmf_res_trueK$fit, var_type = 2), sim_dat))

    all_res <- all_res |> 
      bind_rows(next_tib(shape, ns, "EBNMF0", trueK, run_alternating_gb(Y, Kmax = trueK, var_type = 0), sim_dat))

    all_res <- all_res |> 
      bind_rows(next_tib(shape, ns, "EBNMF2", trueK, run_alternating_gb(Y, Kmax = trueK, var_type = 2), sim_dat))
    
    nmf_res_highK <- run_nmf(Y, k = highK)
    all_res <- all_res |> 
      bind_rows(next_tib(shape, ns, "NMF", highK, nmf_res_highK, sim_dat))
    
    all_res <- all_res |> 
      bind_rows(next_tib(shape, ns, "NMF-EBNMF0", highK, run_ebnmf_from_nmf(Y, nmf_res_highK$fit, var_type = 0), sim_dat))
    
    all_res <- all_res |> 
      bind_rows(next_tib(shape, ns, "NMF-EBNMF2", highK, run_ebnmf_from_nmf(Y, nmf_res_highK$fit, var_type = 2), sim_dat))

    all_res <- all_res |> 
      bind_rows(next_tib(shape, ns, "EBNMF0", highK, run_alternating_gb(Y, Kmax = highK, var_type = 0), sim_dat))

    all_res <- all_res |> 
      bind_rows(next_tib(shape, ns, "EBNMF2", highK, run_alternating_gb(Y, Kmax = highK, var_type = 2), sim_dat))
  }
}
```

## Results, Kmax = 4

Correlations for `L`. Each row gives correlations for one true component (one "population"), with rows arranged according to the abundance of the population (in descending order). Individual tiles correspond to individual simulations (a single combination of gamma shape and rare population size):

```{r}
low_color <- "white"
high_color <- "blue"
na_color <- "black"
xlabel <- "Size of rarest population"
plot_df <- all_res |> filter(Kmax == trueK, str_starts(metric_type, "LLcor")) |>
  mutate(varied_n = factor(varied_n), 
         shape = factor(round(shape, 2)),
         method = factor(method, levels = c("NMF", "NMF-EBNMF0", "NMF-EBNMF2", "EBNMF0", "EBNMF2"))) |>
  mutate(metric_val = pmin(metric_val, 0.99999))
ggplot(plot_df, aes(x = varied_n, y = shape, fill = metric_val)) +
  geom_tile() +
  scale_fill_gradient(low = low_color, high = high_color, na.value = na_color, transform = "logit",
                      breaks = c(0.9, 0.99, 0.999, 0.9999)) +
  facet_grid(rows = vars(metric_type), cols = vars(method), scales = "free_x") +
  labs(x = xlabel, y = "Shape of gamma prior on factors", fill = "Cor. w/ true L") +
  theme(axis.text.x = element_text(angle = 45))
```

Correlations for `F`:

```{r}
plot_df <- all_res |> filter(Kmax == trueK, str_starts(metric_type, "FFcor")) |>
  mutate(varied_n = factor(varied_n), 
         shape = factor(round(shape, 2)),
         method = factor(method, levels = c("NMF", "NMF-EBNMF0", "NMF-EBNMF2", "EBNMF0", "EBNMF2"))) |>
  mutate(metric_val = pmin(metric_val, 0.99999))
ggplot(plot_df, aes(x = varied_n, y = shape, fill = metric_val)) +
  geom_tile() +
  scale_fill_gradient(low = low_color, high = high_color, na.value = na_color, transform = "logit",
                      breaks = c(0.9, 0.99, 0.999, 0.9999)) +
  facet_grid(rows = vars(metric_type), cols = vars(method), scales = "free_x") +
  labs(x = xlabel, y = "Shape of gamma prior on factors", fill = "Cor. w/ true F") +
  theme(axis.text.x = element_text(angle = 45))
```

## Results, Kmax = 8

Correlations for `L`:

```{r}
plot_df <- all_res |> filter(Kmax == highK, str_starts(metric_type, "LLcor")) |>
  mutate(varied_n = factor(varied_n), 
         shape = factor(round(shape, 2)),
         method = factor(method, levels = c("NMF", "NMF-EBNMF0", "NMF-EBNMF2", "EBNMF0", "EBNMF2"))) |>
  mutate(metric_val = pmin(metric_val, 0.99999))
ggplot(plot_df, aes(x = varied_n, y = shape, fill = metric_val)) +
  geom_tile() +
  scale_fill_gradient(low = low_color, high = high_color, na.value = na_color, transform = "logit",
                      breaks = c(0.9, 0.99, 0.999, 0.9999)) +
  facet_grid(rows = vars(metric_type), cols = vars(method), scales = "free_x") +
  labs(x = xlabel, y = "Shape of gamma prior on factors", fill = "Cor. w/ true L") +
  theme(axis.text.x = element_text(angle = 45))
```

Correlations for `F`:

```{r}
plot_df <- all_res |> filter(Kmax == highK, str_starts(metric_type, "FFcor")) |>
  mutate(varied_n = factor(varied_n), 
         shape = factor(round(shape, 2)),
         method = factor(method, levels = c("NMF", "NMF-EBNMF0", "NMF-EBNMF2", "EBNMF0", "EBNMF2"))) |>
  mutate(metric_val = pmin(metric_val, 0.99999))
ggplot(plot_df, aes(x = varied_n, y = shape, fill = metric_val)) +
  geom_tile() +
  scale_fill_gradient(low = low_color, high = high_color, na.value = na_color, transform = "logit",
                      breaks = c(0.9, 0.99, 0.999, 0.9999)) +
  facet_grid(rows = vars(metric_type), cols = vars(method), scales = "free_x") +
  labs(x = xlabel, y = "Shape of gamma prior on factors", fill = "Cor. w/ true F") +
  theme(axis.text.x = element_text(angle = 45))
```

Scale of redundant/noisy factors. If any exist, they are arranged in descending order, with the largest redundant/noisy factor appearing in the top row:

```{r}
plot_df <- all_res |> filter(Kmax == highK, str_starts(metric_type, "Scale")) |>
  mutate(varied_n = factor(varied_n), 
         shape = factor(round(shape, 2)),
         method = factor(method, levels = c("NMF", "NMF-EBNMF0", "NMF-EBNMF2", "EBNMF0", "EBNMF2"))) |>
  mutate(metric_val = pmax(metric_val, 0.00001))
ggplot(plot_df, aes(x = varied_n, y = shape, fill = metric_val)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "red", na.value = "white", transform = "logit",
                      breaks = c(.0001, .001, .01, .1)) +
  facet_grid(rows = vars(metric_type), cols = vars(method), scales = "free_x") +
  labs(x = xlabel, y = "Shape of gamma prior on factors", fill = "Scale") +
  theme(axis.text.x = element_text(angle = 45))
```

## Time elapsed

```{r}
plot_df <- all_res |> filter(str_starts(metric_type, "t_elapsed")) |>
  mutate(varied_n = factor(varied_n), 
         shape = factor(round(shape, 2)),
         Kmax = factor(paste0("Kmax = ", Kmax)),
         method = factor(method, levels = c("NMF", "NMF-EBNMF0", "NMF-EBNMF2", "EBNMF0", "EBNMF2"))) 
ggplot(plot_df, aes(x = varied_n, y = shape, fill = metric_val)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "darkgreen", na.value = "black", transform = "log10") +
  facet_grid(rows = vars(Kmax), cols = vars(method), scales = "free_x") +
  labs(x = xlabel, y = "Shape of gamma prior on factors", fill = "Time elapsed (s)") +
  theme(axis.text.x = element_text(angle = 45))
```
