---
title: NMF analyses of simulated data, Scenario 3 (hierarchical relationships)
author: Jason Willwerscheid and Peter Carbonetto
output:
  workflowr::wflow_html:
    toc: yes
    theme: readable
    highlight: textmate
    lib_dir: site_libs
    self_contained: no
---

```{r knitr-opts, include=FALSE}
knitr::opts_chunk$set(comment = "#",collapse = TRUE,results = "hold",
                      fig.align = "center",dpi = 120)
```

```{r load-pkgs, message=FALSE}
library(R.matlab)
library(tibble)
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(cowplot)
library(ebnm)
library(flashier)
library(fastTopics)
source("./code/sim_functions.R")
```

For details on fitting methods and evaluation metrics, see our previous analysis in `analysis/sim_scenario1b.Rmd`.

## Simulation setting

In this analysis we consider the "hierarchical" scenario. Here there are seven topics: a "root" topic shared by four populations, two "branch" topics shared by two populations each, and four "leaf" topics that are unique to one population each. We also add 7 populations consisting of "anchor documents." We fix the size of the hierarchically-related populations at 400 and vary the number of anchor documents from 5 to 400 per population. The `L` matrix codes population memberships. The factors `F` and the log1p link function are as in the previous analysis.

```{r}
sim_data <- function(ns, p, dispersion, n_anchor_words = 3, link = "log1p") {
  pops <- rep(LETTERS[1:length(ns)], times = ns)
  
  # Loadings (document-topics):
  L <- matrix(0, nrow = sum(ns), ncol = 7)
  L[, 7] <- c(rep(1/3, sum(ns[1:4])), rep(1, ns[5]), rep(0, sum(ns[6:11]))) # root
  L[, 5] <- c(rep(1/3, sum(ns[1:2])), rep(0, sum(ns[3:5])), rep(1, ns[6]), rep(0, sum(ns[7:11]))) # branch 1
  L[, 6] <- c(rep(0, sum(ns[1:2])), rep(1/3, sum(ns[3:4])), rep(0, sum(ns[5:6])), rep(1, ns[7]), rep(0, sum(ns[8:11]))) # branch 2
  L[, 1] <- c(rep(1/3, ns[1]), rep(0, sum(ns[2:7])), rep(1, ns[8]), rep(0, sum(ns[9:11]))) # leaf 1
  L[, 2] <- c(rep(0, ns[1]), rep(1/3, ns[2]), rep(0, sum(ns[3:8])), rep(1, ns[9]), rep(0, sum(ns[10:11]))) # leaf 2
  L[, 3] <- c(rep(0, sum(ns[1:2])), rep(1/3, ns[3]), rep(0, sum(ns[4:9])), rep(1, ns[10]), rep(0, ns[11])) # leaf 3
  L[, 4] <- c(rep(0, sum(ns[1:3])), rep(1/3, ns[4]), rep(0, sum(ns[5:10])), rep(1, ns[11])) # leaf 4

  F <- sim_F(p, 7, gamma_shape = 2/3, gamma_scale = 1, n_anchor_words)
  X <- sim_X(L, F, dispersion = dispersion)
  return_sim_data(X, L, F, pops)
}

run_sims <- function(which_dat, Kmax, verbose = FALSE) {
  all_res <- tibble()
  next_seed <- 0
  for (varied_n in c(5, 10, 25, 100, 400)) { 
    for (disp in c(0.1, 1, 10, 100, 10000)) {
      if (verbose) cat("SHARED N: ", varied_n, "DISPERSION: ", disp, "\n")
      
      ns <- c(rep(400, 4), rep(varied_n, 7))
      p <- 1000
      
      next_seed <- next_seed + 1
      set.seed(next_seed)
      sim_dat <- sim_data(ns, p, disp)
      
      dat <- sim_dat[[which_dat]]
      
      if (verbose) cat(" NMF...\n")
      nmf_res <-  run_RcppML_sparse_nmf(dat, k = Kmax, L1pen = 0, seeds = 1:10)
      all_res <- all_res |> 
        bind_rows(next_tib(next_seed, disp, varied_n, "NMF", Kmax, nmf_res, sim_dat))
      
      L1pens <- c(0.05, 0.1, 0.25, 0.5, 0.75) 
      for (L1pen in L1pens) {
        if (verbose) cat(" Sparse NMF, L1 = ", L1pen, "...\n")
        spnmf_res <- run_RcppML_sparse_nmf(dat, k = Kmax, L1pen = L1pen, seeds = 1:10)
        all_res <- all_res |> 
          bind_rows(next_tib(next_seed, disp, varied_n, paste0("SpNMF", L1pen), Kmax, spnmf_res, sim_dat))
      }
      
      if (verbose) cat(" NMF-EBNMF...\n")
      ebnmf_nmf_res <- run_ebnmf_from_nmf(dat, nmf_res$fit)
      all_res <- all_res |> 
        bind_rows(next_tib(next_seed, disp, varied_n, "NMF-EBNMF", Kmax, ebnmf_nmf_res, sim_dat))
      
      if (verbose) cat(" NMF-EBNMF (var type = 0)...\n")
      ebnmf_nmf_vt0_res <- run_ebnmf_from_nmf(dat, nmf_res$fit, var_type = 0)
      all_res <- all_res |> 
        bind_rows(next_tib(next_seed, disp, varied_n, "NMF-EBNMF-vt0", Kmax, ebnmf_nmf_vt0_res, sim_dat))
      
      if (verbose) cat(" EBNMFgb...\n")
      ebnmf_gb_res <- run_greedy_backfit(dat, Kmax = Kmax)
      all_res <- all_res |> 
        bind_rows(next_tib(next_seed, disp, varied_n, "EBNMFgb", Kmax, ebnmf_gb_res, sim_dat))
      
      if (verbose) cat(" EBNMFgb (var type = 0)...\n")
      ebnmf_gb_vt0_res <- run_greedy_backfit(dat, Kmax = Kmax, var_type = 0)
      all_res <- all_res |> 
        bind_rows(next_tib(next_seed, disp, varied_n, "EBNMFgb-vt0", Kmax, ebnmf_gb_vt0_res, sim_dat))
      
      if (verbose) cat(" EBNMFalt...\n")
      ebnmf_alt_res <- run_alternating(dat, Kmax = Kmax)
      all_res <- all_res |> 
        bind_rows(next_tib(next_seed, disp, varied_n, "EBNMFalt", Kmax, ebnmf_alt_res, sim_dat))
      
      if (verbose) cat(" EBNMFalt (var type = 0)...\n")
      ebnmf_alt_vt0_res <- run_alternating(dat, Kmax = Kmax, var_type = 0)
      all_res <- all_res |> 
        bind_rows(next_tib(next_seed, disp, varied_n, "EBNMFalt-vt0", Kmax, ebnmf_alt_vt0_res, sim_dat))
      
    }
  }
  
  all_res <- all_res |>
    mutate(method = factor(method, levels = c(
      "NMF", paste0("SpNMF", L1pens), "NMF-EBNMF", "NMF-EBNMF-vt0", "EBNMFgb", "EBNMFgb-vt0",
      "EBNMFalt", "EBNMFalt-vt0"
    )))
  
  return(all_res)
}
```


### Results, Kmax = 7

```{r sims_7norm, echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE, results='hide'}
sims_7norm <- run_sims("Ynorm", Kmax = 7, verbose = FALSE)
```

```{r sims_7nonorm, echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE, results='hide'}
sims_7nonorm <- run_sims("Y", Kmax = 7, verbose = FALSE)
```

Cosine similarities for `L` (normalized data). The first four rows (LLcosine1 through LLcosine4) correspond to the "leaf" components. LLcosine5 and LLcosine 6 correspond to the "branch" components, and LLcosine 7 corresponds to the "root" component.

```{r}
xlab <- "Size of leaf population"
ylab <- "Dispersion parameter"
make_cosplot(sims_7norm, "LLcos", xlab, ylab, "Cos. sim. w/ true L")
```

Cosine similarities for `L` (non-normalized data):

```{r}
make_cosplot(sims_7nonorm, "LLcos", xlab, ylab, "Cos. sim. w/ true L")
```

Cosine similarities for `F` (non-normalized data):

```{r}
make_cosplot(sims_7nonorm, "FFcos", xlab, ylab, "Cos. sim. w/ true F", cutoff = 0.999)
```

#### Comments

Interestingly, when the true number of components is specified, NMF-EBNMF does best, but it is only slightly better than NMF or sparse NMF with a small L1 penalty parameter. 


### Results, Kmax = 12

```{r sims_12norm, echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE, results='hide'}
sims_12norm <- run_sims("Ynorm", Kmax = 12, verbose = FALSE)
```

```{r sims_12nonorm, echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE, results='hide'}
sims_12nonorm <- run_sims("Y", Kmax = 12, verbose = FALSE)
```

Cosine similarities for `L` (normalized):

```{r}
make_cosplot(sims_12norm, "LLcos", xlab, ylab, "Cos. sim. w/ true L")
```

SNR for redundant/noisy factors (normalized):

```{r}
make_scaleplot(sims_12norm, xlab, ylab, "SNR", cutoff = 100)
```

Cosine similarities for `L` (non-normalized):

```{r}
make_cosplot(sims_12nonorm, "LLcos", xlab, ylab, "Cos. sim. w/ true L")
```

Cosine similarities for `F` (non-normalized):

```{r}
make_cosplot(sims_12nonorm, "FFcos", xlab, ylab, "Cos. sim. w/ true F", cutoff = 0.999)
```

SNR for redundant/noisy factors (non-normalized):

```{r}
make_scaleplot(sims_12nonorm, xlab, ylab, "SNR", cutoff = 100)
```

#### Comments

When the number of components is mis-specified, all flavors of EBNMF generally outpeform both NMF and sparse NMF, except that alternating EBNMF can miss some hierarchical structure when the leaf populations are small. But alternating EBNMF is also best at removing redundant components.


### Timings

```{r}
all_res <- sims_7norm |>
  bind_rows(sims_7nonorm) |>
  bind_rows(sims_12norm) |>
  bind_rows(sims_12nonorm)
make_timingplot(all_res, xlab, ylab)
```
